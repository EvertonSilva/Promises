/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 */

//
// Design Notes
// ============
//
//  Goals:
//
//    This design for a DOM-compatible Promise type aims to be usable in
//    the majority of the web's single-response asynchronous APIs, either
//    directly or through subclass (e.g., to add progress notification).
//
//    It also aims to enable end-users (non-spec authors) to build systems
//    using these types directly without appealing to libraries or DOM magic
//    for creating/resolving Promises.
//
//    We identify the following features as required:
//
//      * Chaining of .then() calls
//      * Separation of Resolver (who may vend Promises) and Promise
//        implementation, creating the ability for a Resolver to safely hand a
//        Promise to multiple clients whom it does not trust and may not
//        interfere with each other.
//      * Event-friendlyness. As this is a DOM API, it must be possible to
//        register callbacks using the DOM's event mechanism.
//
//    The final goal is to define a future-compatible superset of the Promise
//    design space to allow 
//
//  Non-Goals:
//
//    Unifying or describing the internal behavior of events is a non-goal.
//    Promises are a single-request/single-repose formalism and may capture
//    values from past resposes. Events, on the other hand, describe a series
//    of future events.  They cover separate use-cases and we do not seek to
//    join them here in any way other than to provide a way for receivers of a
//    promise to receive a *future* notification of resolution via event
//    handler.
//
//    Compatibility with existing promises/futures/deferreds libraries or
//    terminology is a non-goal. Where adopting existing terminology improves
//    the usability of this library, we will. Otherwise, appeals to
//    compatibility with published libraries, specifications, and practice are
//    not compelling.
//
//
//  Basic API:
//
//    DOM Promises represent the completion of a single operation, past or
//    future, and provide a uniform API for interacting with individual events,
//    chains of events, and error handling for those events.
//
//    FIXME(slightlyoff): finish outline here!
//
//  Processing model:
//
//    The delivery of any resolution or error MUST BE "apparently
//    asynchronous", specifically they must be delayed at least to the "end of
//    microtask" as defined for the delivery of Mutation Observer and
//    Object.observe() notifications. Delivery at any point beyond that, e.g.
//    in the next turn or microtask, is allowed, but all implementations MUST
//    demonstrate the following behavior:
//
//      var r = new Resolver();
//      assertTrue(r.state == "pending");
//      assertTrue(r.promise.state == "pending");
//
//      r.resolve(null);
//      assertTrue(r.state == "resolved");
//      assertTrue(r.promise.state == "pending");
//
//      try {
//        r.resolve(null);
//        // Not reached
//        assertTrue(false);
//      } catch(e) {
//        // Catch the AlreadyResolved error thrown by the second resolve()
//        assertTrue(e instanceof AlreadyResolved);
//      }
//
//  Chaining:
//
//    Chaining is a requirement, meaning that it must be possible to call
//    ".then()" and receive a sensible result from which you can ".then()"
//    again.
//
//    This is accomplished in the design below through the setting of an
//    internal resolver reference in the Promise implementation, either through
//    the constructor argument or some other mechanism.
//
//    Promises return a new automatically-generated Promise from each "then()
//    call. The then()-generated Promises are resolved by the callbacks passed
//    to each "then()" invocation. These functions are called based on the
//    resolution and their return values are passed onward to the next
//    auto-generated Promise:
//
//      // Example invocation
//      var doItAsync = function() {
//        var r = new Resolver();
//        // ...
//        return r.promise;
//      };
//      doItAsync()
//          .then(onresolve, onreject, oncancel)
//          .then(onresolve)
//          .done(onresolve);
//
//    This architecture gaurantees that resolution goes through a Resolver,
//    meaning that the ability to resolve is not leaked by default (see below).
//
//    In a change from most Promises implementations, we automatically pass the
//    generated resolver to callbacks, allowing them to use/return its promise
//    directly and to cancel, a feature which isn't available through the
//    return-sniffing system:
//
//      doItAsync()
//          .then(function onresolve(value, nextResolver) {
//            // To chain async behavior, we simply operate with the passed
//            // resolver...
//            setTimeout(nextResolver.resolve.bind(nextResolver, "resolved!"), 100);
//
//            // ...and return its promise
//            return nextResolver.promise;
//          })
//          .done();
//
//  Return Value Sniffing and value/error/cancel Chaining:
//
//    Like many other Promise systems, the callbacks for resolve/error/cancel
//    are used to resolve the auto-generated Promise returned from a call to
//    then(). Below is the basic logic for then() callback return handling.
//    Major features:
//
//      * If the return is a Promise, merge the returned Promise's behavior
//        with it.
//      * If the callback throws, resolve the returned promise with an Error
//      * If the return value is any other kind, use it as the "value" for
//        resolving the generated Promise.
//
//      e.g.:
//
//      Promise.prototype.then = function(onresolve, onerror, oncancel) {
//
//        var nextResolver = new Resolver();
//
//        // _onResolution is only for illustration
//        this._onResolution(function(value) {
//          var ret;
//          try {
//            ret = onresolve(value, nextResolver);
//          } catch (e) {
//            nextResolver.reject(e);
//            return nextResolver.promise;
//          }
//
//          if (ret instanceof Promise) {
//            if (ret !== nextResovler.promise)
//              // Merge the resolution of nextResolver with the returned
//              // Promise.
//              ret.then(nextResolver.resolve.bind(nextResolver),
//                       nextResolver.reject.bind(nextResolver),
//                       nextResolver.cancel.bind(nextResolver));
//            }
//          } else {
//            nextResolver.resolve(ret);
//          }
//        });
//
//        // error and cancellation handling omitted for space
//
//        return nextResolver.promise;
//      };
//
//  Delivery order:
//
//    1.) then() callbacks in the order of registration
//    2.) dispatchEvent()
//
//  Mutual suspicion:
//
//    Promises abstract (partially or fully) over the following capabilties:
//
//      * The ability to resolve the promise
//      * The ability to register to be notified of the resolution
//
//    As with all systems that try to enforce mutual suspicion under the roof
//    of a single heap, designing to vend these capabilities via object
//    identity ("OCAP") is deeply fraught and when relied on in lieu of the
//    clunkier token-based capabilties systems, systems become predictably
//    brittle. Security boundaries remain difficult to reason about as *any*
//    function boundary may have equally large (and catastrophic) security
//    implications. Throwing the "this is a security-sensitive API!" flag is
//    much harder to do in the API design phase when simple value passing and
//    return are hijacked to perhaps mean "capability leaking".
//
//    Despite the risks in OCAP, we expect that DOM Promises will be used with
//    Structured Clone and will be "sendable", so it make sense to treat the
//    Resolver/Promise reference relationship as something that can be split by
//    a (hidden) protocol. As a result, we park *all* sensitive capabilities
//    related to a Promise in the Resolver that creates it.
//
//      // Vending a promise to multiple 
//      FIXME(slightlyoff):
//
//  Errors and Exceptions:
//
//    As seen in the example code above, exceptions throw by callback handlers
//    are caught by the system. This leads to some particular debugging hazards
//    which other systems have treated in various ways. Some have opted simply
//    not to swallow errors. Some propigate errors in various ways (this design
//    employs a variant of that approach). 
//
//    What is clear is that no matter what approach is pursued, integration
//    with developer tooling is key. Developer consoles SHOULD log un-caught
//    errors from promise chains. That is to say, if r.then(onresponse); this
//    should throw an exception in onresponse, 
//
//  Example use:
//

module events {

    // Promises begin in the "pending" state and progress to other
    // states. Once moved from the "pending" state, they may never be
    // returned to it.
    enum PromiseState {
      "pending",
      "resolved",
      "rejected",
      "cancelled"
    };

    // FIXME(slightlyoff):
    //      Require the Resolver parameter to the ctor?
    [Constructor,
     Constructor(Resolver resolver)]
    interface Promise : EventTarget {
        // Events

        // We to notify observers we use the following DOM events which can be
        // registered through the usual mechanism:
        //
        //   resolve
        //     Bubbles: No
        //     Cancelable: No
        //     Context Info: value
        //
        //   cancel
        //     Bubbles: No
        //     Cancelable: No
        //     Context Info:
        //
        //   reject
        //     Bubbles: No
        //     Cancelable: No
        //     Context Info: error
        //
        // Each of these events may be dispatched *only once*

        // markm points out that we need to be able to distinuish between all
        // available states:
        //
        //   pending       (cancelled == false && value == null && error == null)
        //   resolved      (cancelled == false && value != null)
        //   rejected      (cancelled == false && value == null && error != null)
        //   cancelled     (cancelled == true);

        attribute readonly Object value;
        attribute readonly Object error;
        attribute readonly Boolean cancelled;
        attribute readonly PromiseState state;

        // Returns a Promise whose completion value will be the return value
        // from whichever of the callbacks is eventually invoked.
        Promise then(in [Optional] Function onresolve,
                     in [Optional] Function onreject,
                     in [Optional] Function oncancel);

        void    done(in [Optional] Function onresolve,
                     in [Optional] Function onreject,
                     in [Optional] Function oncancel);

    };

    // FIXME(slightlyoff):
    //      Allow an optional value/error param for automatic resoluton, i.e.
    //      MSFT's "as"?
    [Constructor]
    interface Resolver {

        // "resolve" and "reject" may be called *only once*, after
        // which point they throw exceptions. Setters fire onoresolve or
        // onreject on the owned promise.

        void resolve(in Object value); // AlreadyResolved
        void reject(in [Optional] Error error);
        void cancel() raises(Error); // AlreadyCanceled || AlreadyResolved

        attribute readonly PromiseState state;
        attribute [readonly] Promise promise;
    };
};
